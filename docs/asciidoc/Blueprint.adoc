= Infinite Logging âˆž BlackBox
Anton Pryamostanov <https://github.com/apryamostanov[@apryamostanov]>
:description: This Blueprint defines the solution to automatically generate Groovy <<Semantic logging>> code and inject it into <<User code>> during the <<Compilation stage>> resulting in a possibility to produce and review exhaustive application runtime data in a form of XML files with <<XSD model>> based on simplified Groovy AST class model - by the means of developing and using a <<BlackBox Annotation,Groovy Annotation>>.
:keywords: Groovy, AST, annotation, transformation, logging, code injection, semantic logging
:page-description: {description}
:page-keywords: {keywords}
:page-layout: docs
ifndef::env-site[]
:toc:
:toclevels: 2
:icons: font
:idprefix:
:idseparator: -
:sectanchors:
:sectlinks:
:source-highlighter: highlightjs
endif::[]
:experimental:
:mdash: &#8212;
:language: asciidoc
:source-language: {language}
:table-caption!:
:example-caption!:
:figure-caption!:
:imagesdir: ../images
:includedir: _includes
:source-highlighter: Coderay coderay
:sectnums:
:sectnumlevels: 10
// Refs
:blackbox-blueprint: https://github.com/INFINITE-TECHNOLOGY/BLACKBOX/wiki/Blueprint
:blackbox-code: https://github.com/INFINITE-TECHNOLOGY/BLACKBOX

////
TODO:

////

== Purpose
{description}

== In short
<<BlackBox Annotation>> automatically injects a lot of logging code into user-defined Groovy methods/constructors without affecting the user program logic. +
Granularity of injected code can be defined by the user (programmer) up to:

* <<Method Exception handling transformation, Method Exceptions logging>> (exception and causing method arguments are logged)
* <<Method transformation, Method invocation logging>> (method arguments and result are logged)
* <<Statement transformation, Statement-level logging>>
* <<Expression transformation, Expression-level logging>>

== Introduction

=== Foreword

<<Logging>> is one of the most important parts of modern applications. +
Its significance only increases in case of:

* Financial environments (consider PCI-DSS and sensitive data logging)
* Cloud environments (consider logging to Logstash)
* GDPR

Some scenarios when logging is useful include:

* Network data exchange (TCP, HTTP, SOAP, REST)
* Periphery communication (Bluetooth, serial port, USB, etc)
* IOT (I2C, SPI)
* Automotive communication (Canbus and its implementations)

=== The Problem

While at a level of <<Logging Engine, Logging engines>> (Log4J, JUL, Logback -> SLF4J) things are good, there is a methodological gap in terms of approach and best practices for logging integration into <<User code>> as well as its automation. +
In short there is *no set of rules* helping programmers to understand:

* *What* to log
* *How* to structure the log data
* *When* to log
* *Where* to place logging code in the application
* *How* log can be used on Test and Production environments
* *Why* spend time writing logging code

When it comes to automation of logging in Java and Groovy, the things are getting really bad:

* Groovy provides annotations (@Slf4j, etc) to inject log variable declaration and initialization

That saves just a couple of lines of code. +
But there is *no real way to inject the actual logging code into the application*. +
Programmers have to manually place lines with logging leading to *unwanted results*:

* Cluttering the real code base with logging code
* Unstructured and cluttered log output
* Chances of misplacing the logging code and missing important output
* Increase of development time and costs

=== The Solution

As an Open Source community we are taking an initiative to come up with a new Logging solution addressing these limitations and supporting many additional features. +

The *"BlackBox" solution helps* to address the key questions:

.Addressed cases
====
* *What* to log:
** 4 levels of logging:
*** Method exceptions (with arguments causing exception)
*** Method execution (with method arguments, result and exceptions)
*** Statements execution within the method (all Groovy statements are supported)
*** Expression execution and evaluation (all Groovy expressions are supported) - with the resulting object value and class
** Compile-time metadata:
*** Line numbers
*** Code snippets
* *How* to structure the log data
** Log data is automatically structured into XML files according to XSD therefore leaving no room for disambiguation when it comes to interpretation of log data.
* *When* to log
** 2 operational modes are supported:
*** *Sequential* real-time - *an alternative to using Debugger*.
There are many situations when it is easier to run a program - and then to read the hierarchical execution output like in above example to identify bugs or understand why specific branch of AST has been run. With the Debugger it will take a lot of time by manually putting Breakpoints and Watches.
*** *Emergency* - suitable for using on *Production* - when Unhandled exception happens - the whole AST route with all runtime data (method Arguments, method results, expression values and associated meta data (line numbers, etc)) - is printed up to the place where exception has been encountered. This acts an alternative to Memory dump, with a difference that such trace has retrospective data (not only that last memory snapshot).
* *Where* to place logging code in the application
** Simply add @BlackBox annotation to the method - and the job is done. No need to clutter the actual code with logging lines.
* *How* log can be used on Test and Production environments
** Issue investigation & debugging
** Performance profiling and optimization
** Statistics
** Analytics
*** Uploading to Logstash
*** Applying XSLT to log XML for easier analysing
** Monitoring
** Telemetry
** Journaling
* *Why* spend time writing logging code
** To save the time used to write logging code
====

TIP: For example consider scenario of finding which specific "return" statement returned by placing logging or using debugger.


=== Terminology


==== Logging

Logging is a process of saving *structured* data on a permanent storage with assumption that it may be used in future. +
However it is neither known how and when this data will be used neither it is guaranteed that this data is useful.


==== Logging Engine

Logging Engine is a library that provides an API to save log data. +

IMPORTANT: Logging Engine does not define neither the structure itself nor API of structuring the log data. +
Logging Engine defines only structure of log record format (such as adding timestamp and thread infromation), while the input data comes in its final form from outside of the log engine.

Example Logging Engines are:

* Log4J
* Logback
* Others

==== User code

Code written by application programmers for business or other purposes.


==== Semantic logging

Semantic-level logging is a technique which helps to trace application execution flow as per code semantic structures such as:

<1> Method execution start and end
<2> Method arguments and result
<3> Statements such as if/else
<4> Expressions such as assignment expression


==== BlackBox

Black box is a hardware device in the airplane that keeps record of flight parameters and flight control system operation signals (such as flaps control).

BlackBox solution acts as a software Black box for your programs helping to recover data that has caused exceptions in <<User code>>.

== Key Features

=== Code writing stage

==== BlackBox Annotation

@BlackBox annotation is applicable to:

<1> Methods
<2> Constructors

.Example:
[source,groovy]
----
@BlackBox
String foo() {
    return "bar"
}
----
To start using <<The Solution, BlackBox>>, add the <@BlackBox annotation as shown above. It is as simple as that!

===== 4 BlackBox levels
Specify explicitly the needed level of logging code injection granularity by providing "blackBoxLevel" parameter to @BlackBox annotation:

[source,groovy]
----
@BlackBox(blackBoxLevel = BlackBoxLevel.EXPRESSION)
String foo() {
    return "bar"
}
----
There are 5 possible values for the "blackBoxLevel" annotation parameter:

<0> BlackBoxLevel.NONE - method is unmodified
<1> BlackBoxLevel.METHOD_ERROR - corresponds to <<Method Exception handling transformation>>
<2> BlackBoxLevel.METHOD - corresponds to <<Method transformation>>
<3> BlackBoxLevel.STATEMENT - enables <<Statement transformation>> in addition to BlackBoxLevel.METHOD
<4> BlackBoxLevel.EXPRESSION - enables <<Expression transformation>> in addition to BlackBoxLevel.METHOD and BlackBoxLevel.STATEMENT

=== Compilation stage
During the compilation phase <<The Solution, BlackBox>> performs transformation of methods and constructors having the @BlackBox annotation.
As the result Method/Constructor code is modified having the additional logging added, while the method signatures and the actual functionality of the method are preserved.

==== Method transformation and Log code injection levels
===== Method Error
.*Before:*
[source,groovy]
----
@BlackBox(blackBoxLevel = BlackBoxLevel.METHOD_ERROR)
String foo(String bar) {
    return bar
}
----

.*After:*
[source,groovy,linenums]
----
String foo(String bar) {
    try {
        return bar
    } catch (java.lang.Throwable automaticThrowable) {
        io.infinite.blackbox.BlackBoxEngine automaticBlackBox = io.infinite.blackbox.BlackBoxEngine.getInstance()
        automaticBlackBox.methodExecutionOpen('SandBox', 'io.infinite.blackbox', 'foo', 5, 6, 29, 32, ['bar': bar])
        automaticBlackBox.exception(automaticThrowable)
        automaticBlackBox.executionClose()
        throw automaticThrowable
    }
}
----

Method code is enclosed into Try/Catch statement and in case exception happens during execution of method code - it is logged *along with the method parameters which caused the exception.* +

IMPORTANT: *This is one of the key functionalities of <<The Solution, BlackBox>>* - in this scenario there is practically no performance impact on normal application execution - however if unhandled exception occurs - *we are now automatically aware of the Method Arguments which caused the exception.*

===== Method
.*Before:*
[source,groovy]
----
@BlackBox(blackBoxLevel = BlackBoxLevel.METHOD)
String foo(String bar) {
    return bar
}
----

.*After:*
[source,groovy,linenums]
----
String foo(String bar) {
    io.infinite.blackbox.BlackBoxEngine automaticBlackBox = io.infinite.blackbox.BlackBoxEngine.getInstance()
    automaticBlackBox.methodExecutionOpen('SandBox', 'io.infinite.blackbox', 'foo', 5, 6, 29, 32, ['bar': bar ])
    try {
        automaticBlackBox.executeMethod({
            return bar
        })
    }
    catch (java.lang.Throwable automaticThrowable) {
        automaticBlackBox.exception(automaticThrowable)
        throw automaticThrowable
    }
    finally {
        automaticBlackBox.executionClose()
    }
}
----

<1> Method code is *enclosed with Closure* and Try/Catch statement.
<2> Method code execution is preceeded with *logging of method arguments*.
<3> Method code closure is passed to "executeMethod" which *logs method result*.
<3> Any exception are logged
<4> Finally method execution completion is logged (regardless of whether it is due to unhandled exception or Return statement).

NOTE: Method arguments, result and exceptions are logged. Method code is not modified.

===== Statement
.*Before:*
[source,groovy]
----
@BlackBox(blackBoxLevel = BlackBoxLevel.STATEMENT)
String foo(String bar) {
    return bar
}
----

.*After:*
[source,groovy,linenums]
----
String foo(String bar) {
    io.infinite.blackbox.BlackBoxTransformation - io.infinite.blackbox.BlackBoxEngine automaticBlackBox = io.infinite.blackbox.BlackBoxEngine.getInstance()
    automaticBlackBox.methodExecutionOpen('SandBox', 'io.infinite.blackbox', 'foo', 5, 6, 29, 32, ['bar': bar ])
    try {
        automaticBlackBox.executeMethod({
            automaticBlackBox.preprocessControlStatement('ReturnStatement', '\nreturn bar \n', 9, 19, 31, 31, 'BlockStatement:statements')
            return bar
        })
    }
    catch (java.lang.Throwable automaticThrowable) {
        automaticBlackBox.exception(automaticThrowable)
        throw automaticThrowable
    }
    finally {
        automaticBlackBox.executionClose()
    }
}
----

* BlackBox level "STATEMENT" performs same steps as "METHOD", however *it also transforms the method code.* +
* The *statements* within the method are transformed according to BlackBox transformation rules, adding logging to method execution while preserving the original functional flow of the method code. +
* For example in the above method the BlackBox transformation encloses "Return" statement into a closure, which is executed with logging of the line numbers and other meta data of "Return" statement during runtime.

===== Expression
.*Before:*
[source,groovy]
----
@BlackBox(blackBoxLevel = BlackBoxLevel.EXPRESSION)
String foo(String bar) {
    return bar
}
----

.*After:*
[source,groovy,linenums]
----
String foo(String bar) {
    io.infinite.blackbox.BlackBoxEngine automaticBlackBox = io.infinite.blackbox.BlackBoxEngine.getInstance()
    automaticBlackBox.methodExecutionOpen('SandBox', 'io.infinite.blackbox', 'foo', 5, 6, 29, 32, ['bar': bar ])
    try {
        automaticBlackBox.executeMethod({
            automaticBlackBox.preprocessControlStatement('ReturnStatement', '\nreturn bar \n', 9, 19, 31, 31, 'BlockStatement:statements')
            return automaticBlackBox.expressionEvaluation('VariableExpression', 'bar ', 16, 19, 31, 31, {
                return bar
            }, 'ReturnStatement:expression')
        })
    }
    catch (java.lang.Throwable automaticThrowable) {
        automaticBlackBox.exception(automaticThrowable)
        throw automaticThrowable
    }
    finally {
        automaticBlackBox.executionClose()
    }
}
----

* BlackBox level "EXPRESSION" performs same steps as "STATEMENT", however *it also transforms the expressions.* +
* The *expressions* within the method are transformed according to BlackBox transformation rules, adding logging to method execution while preserving the original functional flow of the method code. +
* This helps to log the expression evaluation results and have an exhaustive runtime data for methods having BlackBox annotation.
* For example in the above method the BlackBox transformation encloses "Return" statement *expression* into a closure, which is executed with logging of the line numbers and other meta data of expression during runtime - *as well as expression evaluation result*.

=== Runtime
The injected/transformed code is taking it's effect during runtime (execution) of user program. +
The runtime behavior can be controlled by 2 factors:

* BlackBox System Property "blackbox.mode" which can accept the values from *BlackBoxMode* enumeration and define the Operation Mode (see below section):
** BlackBoxMode.SEQUENTIAL - corresponds to Real-time sequential Operation mode of BlackBox
** BlackBoxMode.EMERGENCY - corresponds to Emergency Operation mode of BlackBox

Sample code snippet to set the property programmatically:
----
System.setProperty("blackbox.mode", BlackBoxMode.SEQUENTIAL.value())
----

* Slf4j->Logback configuration - BlackBox currently uses only Logback via Slf4j as logging engine. Therefore normal Logback configuration methodology will affect the logs produced by BlackBox.

BlackBox currently uses Logback *debug* level for its output. +
There are 2 classes producing the debug output:

* io.infinite.blackbox.BlackBoxEngineSequential
* io.infinite.blackbox.BlackBoxEngineEmergency
For example to enable BlackBox output in Spring Boot *application.properties* define parameters:
----
logging.level.io.infinite.blackbox.BlackBoxEngineSequential=debug
logging.level.io.infinite.blackbox.BlackBoxEngineEmergency=debug
----

==== Operating modes
BlackBox provides 2 operating modes for different usage scenarios.

===== Real-time sequential
This mode is useful for *development/debugging* acting as a supplement/alternative approach to using a Debugger. +
In this mode the logging code injected during compilation phase (as per BlackBox level values defined during writing the code) is executed and the results *immediately sent to Logback for printing the logs.* +
For example *execution* of the below code:

[source,groovy]
----
package io.infinite.blackbox

class SandBox implements Runnable {

    @BlackBox(blackBoxLevel = BlackBoxLevel.EXPRESSION)
    String foo(String bar) {
        return bar
    }

    @Override
    void run() {
        foo("z")
    }
}
----

Will *output* the following results:
----
15:59:49.150 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential - <rootAstNode startDateTime="2018-10-22T15:59:49.120+04:00" xmlns="https://i-t.io/logging/groovy/2_x_x/BlackBox.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
15:59:49.151 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -     <astNodeList>
15:59:49.182 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -         <astNode xsi:type="MethodNode" methodName="foo" className="io.infinite.blackbox.SandBox" startDateTime="2018-10-22T15:59:49.156+04:00" lineNumber="29" columnNumber="5" lastLineNumber="32" lastColumnNumber="6">
15:59:49.182 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -             <argumentList>
15:59:49.182 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                 <argument argumentClassName="java.lang.String" argumentName="bar">
15:59:49.211 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     <argumentValue>z</argumentValue>
15:59:49.213 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                 </argument>
15:59:49.213 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -             </argumentList>
15:59:49.213 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -             <astNodeList>
15:59:49.219 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                 <astNode xsi:type="Statement" statementClassName="ReturnStatement" startDateTime="2018-10-22T15:59:49.217+04:00" sourceNodeName="BlockStatement:statements" lineNumber="31" columnNumber="9" lastLineNumber="31" lastColumnNumber="19">
15:59:49.220 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     <restoredScriptCode>
return bar
</restoredScriptCode>
15:59:49.220 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     <astNodeList>
15:59:49.224 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     </astNodeList>
15:59:49.224 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                 </astNode>
15:59:49.227 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                 <astNode xsi:type="Expression" expressionClassName="VariableExpression" startDateTime="2018-10-22T15:59:49.226+04:00" sourceNodeName="ReturnStatement:expression" lineNumber="31" columnNumber="16" lastLineNumber="31" lastColumnNumber="19">
15:59:49.228 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     <restoredScriptCode>bar </restoredScriptCode>
15:59:49.228 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     <astNodeList>
15:59:49.232 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     </astNodeList>
15:59:49.232 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     <expressionValue className="java.lang.String">
15:59:49.232 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                         <value>z</value>
15:59:49.232 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                     </expressionValue>
15:59:49.232 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                 </astNode>
15:59:49.233 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -             </astNodeList>
15:59:49.233 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -             <methodResult className="java.lang.String">
15:59:49.233 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -                 <value>z</value>
15:59:49.233 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -             </methodResult>
15:59:49.234 [Compilation_SandBox.foo] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -         </astNode>
z
15:59:49.255 [BlackBoxEngine Shutdown Hook 13] DEBUG io.infinite.blackbox.BlackBoxEngineSequential -     </astNodeList>
15:59:49.256 [BlackBoxEngine Shutdown Hook 13] DEBUG io.infinite.blackbox.BlackBoxEngineSequential - </rootAstNode>

Process finished with exit code 0
----

From the above output we can easily track what methods are being called with which parameters, their execution flow and effects as well as results. +
*We know all what happens in the application up to each and every bit.*

===== Emergency
This mode is useful for *production* usage providing details only in case when unhandled exception occurs. +

IMPORTANT: In this mode BlackBox remains *silent* and does not produce any logging debug output unless exception is encountered. +
Output is printed only in case when exception is encountered. +
Printed output is only relevant to encountered exception. Irrelevant data is not printed.

In this mode the logging code injected during compilation phase (as per BlackBox level values defined during writing the code) is executed and the results are *accumulated in RAM without printing the output*. +
*Successful* completed AST execution results are *discarded* from RAM.
In case when *exception* occurs - those AST execution in RAM that are incomplete (in progress) at the time of exception encouter - are sent to Logback for printing. +
For example *execution* of the below code:

[source,groovy]
----
package io.infinite.blackbox

class SandBox implements Runnable {

    @BlackBox(blackBoxLevel = BlackBoxLevel.EXPRESSION)
    String foo(String bar) {

        return bar
    }

    @Override
    void run() {
        foo("z")
    }
}
----

Will *output* the following results (only after exception occurs):

----
16:17:41.085 [Compilation_SandBox.foo] ERROR io.infinite.blackbox.BlackBoxEngineEmergency - <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<rootAstNode xsi:type="MethodNode" methodName="foo" className="io.infinite.blackbox.SandBox" startDateTime="2018-10-22T16:17:40.843+04:00" lineNumber="29" columnNumber="5" lastLineNumber="35" lastColumnNumber="6" xmlns="https://i-t.io/blackbox/groovy/2_x_x/BlackBox.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <astNodeList/>
    <argumentList>
        <argument argumentClassName="java.lang.String" argumentName="bar">
            <argumentValue>foobar</argumentValue>
        </argument>
    </argumentList>
    <exception exceptionDateTime="2018-10-22T16:17:40.913+04:00">
        <exceptionStackTrace>java.lang.Exception: Bar can not be foobar
	at io.infinite.blackbox.SandBox$_foo_closure1$_closure3.doCall(SandBox.groovy:32)
	at io.infinite.blackbox.SandBox$_foo_closure1$_closure3.doCall(SandBox.groovy)
	at io.infinite.blackbox.BlackBoxEngine.expressionEvaluation(BlackBoxEngine.groovy:70)
	at io.infinite.blackbox.BlackBoxEngine$expressionEvaluation$3.call(Unknown Source)
	at io.infinite.blackbox.SandBox$_foo_closure1.doCall(SandBox.groovy:32)
	at io.infinite.blackbox.SandBox$_foo_closure1.doCall(SandBox.groovy)
	at io.infinite.blackbox.BlackBoxEngine.executeMethod(BlackBoxEngine.groovy:175)
	at io.infinite.blackbox.BlackBoxEngine$executeMethod$1.call(Unknown Source)
	at io.infinite.blackbox.SandBox.foo(SandBox.groovy)
	at io.infinite.blackbox.SandBox.run(SandBox.groovy:40)
</exceptionStackTrace>
    </exception>
</rootAstNode>
----

NOTE: Every exception causes such printing only once and during it's first encouter within the BlackBox annotated methods.

NOTE: Only AST Nodes that are part of exception execution stack are printed. Unneeded successful branches of AST that did not cause this exception are discarded and not stored/printed.

== Principles
This section describes basic principles in the foundation of BlackBox solution.

IMPORTANT: Assurance of compliance to these principles must define the Test Strategy of the solution.

=== Thread safety
NOTE: Java execution stack thread affinity is *immutable*. +
This guarantees that even in Application server deployment - *execution started in a specific thread - will always take place and end only and only within the same thread*. +
See also: https://stackoverflow.com/questions/52605879/java-application-servers-execution-stack-thread-affinity +

BlackBox is maintaining the application execution stack in a variable in the instances of BlackBoxEngine class. +
Therefore we need to ensure that each and every thread using BlackBox engine has a designated instance of BlackBoxEngine class. +
This is achieved by having a static ThreadLocal field in BlackBoxEngine and accessing the dedicated-per-thread BlackBoxEngine via *getInstance* method:

----
io.infinite.blackbox.BlackBoxEngine automaticBlackBox = io.infinite.blackbox.BlackBoxEngine.getInstance()
----

NOTE: Above code is provided for information only and it is not required to manually initialize BlackBoxEngine - all the necessary job is done by the injected code automatically.

NOTE: Java application servers interfere with normal java.lang.ThreadLocal class instances. Therefore BlackBox is currently using its own (simplified) implementation of ThreadLocal (which is just a Map<Thread, BlackBoxEngine>).

=== Memory leakage prevention
Runtime data can accumulate indefinitely therefore it is needed to ensure that the portion of Runtime data maintained by BlackBox (in RAM) corresponds only to current active branch of AST execution. +
Completed AST branches are discarded from storage in BlackBoxEngine execution stack.

=== Code equivalency
Since @BlackBox annotation is performing transformation of user code, as a base principle of transformation it needed to ensure that the transformed code is *equivalent* to the initial user code in terms of its actual functionality excluding the additional injected logging code. +
This principle should guarantee that @BlackBox annotation can be safely added to any existing or new Groovy methods and constructors, minimizing risk of regression issues.

== Solution architecture

=== Transformation rules
BlackBox follows a clearly defined set of code transformation rules. +
All Groovy AST Statements and Expressions are subject for transformation using these rules, depending on <<4 BlackBox levels,BlackBox level>>. +

==== Method Exception handling transformation

Method Exception handling transformation is performed when <<4 BlackBox levels,BlackBox level>> is set to "METHOD_ERROR".

====
[source,groovy]
----
try {
    <original Method Code> # <1>
} catch (java.lang.Throwable automaticThrowable) {
    io.infinite.blackbox.BlackBoxEngine automaticBlackBox = io.infinite.blackbox.BlackBoxEngine.getInstance()
    automaticBlackBox.methodExecutionOpen(<metadata>, <method arguments>) # <2> <3>
    automaticBlackBox.exception(automaticThrowable)
    automaticBlackBox.executionClose()
    throw automaticThrowable
}
----
<1> Unmodified original method code
<2> Meta data includes:
* Method declaring class package name
* Method declaring class simple name
* Method name
* First and last line and column numbers of the method code
<3> Method arguments at their state when exception has been catched
====

NOTE: *visit* method is *NOT* called on method code and the AST traversing/transformation terminates  at this stage.

==== Method transformation

Method transformation is performed when <<4 BlackBox levels,BlackBox level>> is set to "METHOD".

====
[source,groovy]
----
io.infinite.blackbox.BlackBoxEngine automaticBlackBox = io.infinite.blackbox.BlackBoxEngine.getInstance()
automaticBlackBox.methodExecutionOpen(<metadata>, <method arguments>) # <1> <2>
try {
    automaticBlackBox.executeMethod({
        <original method code> # <3>
    })
}
catch (java.lang.Throwable automaticThrowable) {
    automaticBlackBox.exception(automaticThrowable)
    throw automaticThrowable
}
finally {
    automaticBlackBox.executionClose()
}
----
<1> Meta data includes:
* Method declaring class package name
* Method declaring class simple name
* Method name
* First and last line and column numbers of the method code
<2> Method arguments at their state *before* method execution
<3> Unmodified original method code
====

NOTE: *visit* method is *NOT* called on method code and the AST traversing/transformation terminates  at this stage.

==== Statement transformation

Statement transformations are applied when <<4 BlackBox levels,BlackBox level>> is set to "STATEMENT" and above. +
In addition to "Method" transformation, *visit* method is called on method code and all statements are transformed according to the below rules:

===== Standard Statement transformation

====

All statements (except Control Statements) are subject to below transformation:

[source,groovy]
----
automaticBlackBox.statementExecutionOpen(<Statement Class Name>, <Original Untransformed Statement Code String>, <statement start and end line and column numbers>, <source AST node variable name>)
<recursively transformed initial statement - child statements and expressions (if needed) transformed>
automaticBlackBox.executionClose()
----

.Example:
[source,groovy]
----
automaticBlackBox.statementExecutionOpen('IfStatement', 'if ( bar == \'foobar\') {\n    throw new java.lang.Exception(\'Bar can not be foobar\')\n}\n', 9, 10, 31, 33, 'BlockStatement:statements')
if ( bar == 'foobar') {
    automaticBlackBox.preprocessControlStatement('ThrowStatement', 'throw new java.lang.Exception(\'Bar can not be foobar\')\n', 13, 57, 32, 32, 'BlockStatement:statements')
    throw new java.lang.Exception('Bar can not be foobar')
}
automaticBlackBox.executionClose()
----

====

:outerinner:: "Outer" transformation means outside corresponding *visit* method of the expression. "Inner" means inside "visit" method.

===== Control Statement transformation

====

TIP: Control statement is a statement that affects the order of statements execution in the program.

There are 4 types of Control Statements in Groovy:

<1> Return
<2> Continue
<3> Break
<4> Throw

These statements represent a special case for BlackBox transformation as they affect the application execution flow. Each one of them has a different scope of effect, and this scope is resolved at runtime using *preprocessControlStatement* method. +
Therefore such statements have to be logged and transformed using different rules than other statements.

[source,groovy]
----
automaticBlackBox.preprocessControlStatement(<Control statement class name>, <Original Untransformed Control Statement Code String>, <control statement start and end line and column numbers>, <source AST node variable name>)
<original control statement (Return, Continue, Break or Throw)>
----

.Example:
[source,groovy]
----
automaticBlackBox.preprocessControlStatement('ThrowStatement', 'throw new java.lang.Exception(\'Bar can not be foobar\')\n', 13, 57, 32, 32, 'BlockStatement:statements')
throw new java.lang.Exception('Bar can not be foobar')
----

====

===== Statement transformation rules

NOTE: {outerinner}

[cols="a,a,a,a"]
|===
|Statement Class|Statement self transformation (always *outer*)|Expression child nodes transformations (all children always visited) (always *inner*)|Comments

|BlockStatement|<<Standard Statement transformation>>|* statements
|

|ForStatement|<<Standard Statement transformation>>|* collectionExpression
* loopBlock
|

|WhileStatement|<<Standard Statement transformation>>|* booleanExpression
* loopBlock
|

|DoWhileStatement|<<Standard Statement transformation>>|* booleanExpression
* loopBlock
|

|IfStatement|<<Standard Statement transformation>>|* booleanExpression
* ifBlock
* elseBlock
|

|ExpressionStatement|<<Standard Statement transformation>>|* expression
|

|ReturnStatement|<<Control Statement transformation>>|* expression
|Child Expression is transformed only non-void methods

|AssertStatement|<<Standard Statement transformation>>|* booleanExpression
* messageExpression
|

|TryCatchStatement|<<Standard Statement transformation>>|* tryStatement
* code (catchStatements)
* finallyStatement
| All catch statements are transformed

|EmptyStatement|No transformation|
|

|SwitchStatement|<<Standard Statement transformation>>|* expression
* code (switchStatements)
* defaultStatement
| All case statements are transformed

|CaseStatement|<<Standard Statement transformation>>|* expression
* code
|

|BreakStatement|<<Control Statement transformation>>|No transformation
|

|ContinueStatement|<<Control Statement transformation>>|* No transformation
|

|SynchronizedStatement|<<Standard Statement transformation>>|* expression
* code
|

|ThrowStatement|<<Control Statement transformation>>|* expression
|

|CatchStatement|<<Standard Statement transformation>>|* code
|

|===

==== Expression transformation

Expression transformations are applied when <<4 BlackBox levels,BlackBox level>> is set to "EXPRESSION".

Unless specified differently, any expression undergoes the below default transformation:

===== Standard Expression transformation

====

All expressions except DeclarationExpression are subject to below transformation:

[source,groovy]
----
automaticBlackBox.expressionEvaluation(<Expression Class Name>, <Original Untransformed Expression Code String>, <statement start and end line and column numbers>, {
                <recursively transformed initial expression - child statements and expressions (if needed) transformed>
}, <source AST node variable name>)
----

Example:
[source,groovy]
----
automaticBlackBox.expressionEvaluation('VariableExpression', 'bar ', 16, 19, 31, 31, {
                return bar
}, 'ReturnStatement:expression')
----

====

===== Declaration Expression transformation

====

DeclarationExpression is *Not* wrapped into MethodCallExpression - it is rather transformed into ListOfExpressionsExpression having the below expressions:

<1> Injected logging code (MethodCallExpression)
<2> Self expression after child nodes transformations
<3> Injected logging code (MethodCallExpression)

* leftExpression of declaration is never transformed

IMPORTANT: Furthermore - leftExpression of DeclarationExpression is *not* visited.
This is the only case when BlackBox AST traversing is terminated prematurely.

* Right expression is transformed
* Usage of ListOfExpressionsExpression is a hack
** it works in similar way to BlockStatement - however such usage is "undocumented feature" of Groovy AST

TIP: *Q*: Why do we inject code only for DeclarationExpression (by adding expressions into ListOfExpressionsExpression) and replace other Expressions with MethodCall expression? +
*A*: Declaration expression does not evaluate itself to object and can't be replaced with MethodCall expression. +

NOTE: VariableScopeVisitor must be able to declare the variable after BlackBox transformation into the same branch of variable scopes. +
Thus we have to *surround* DeclarationExpression with logging code (MethodCall expressions) and replace it with ListOfExpressionsExpression.

====

===== Expression transformation rules

NOTE: See also https://issues.apache.org/jira/browse/GROOVY-8834

NOTE: Only expressions that actually evaluate to object are transformed.
Contrary to definition of Expression, in Groovy not all expressions evaluate to object.
*Example:*
====
Declaration expression does not evaluate to object
====

IMPORTANT: BlackBox transformation visits all AST Nodes. Thus whole AST is visited/transformed. The only exception is *DeclarationExpression.leftExpression*.

Expression transformations follow the rules in the below table:

NOTE: {outerinner}

[cols="a,a,a,a,a"]
|===
|Expression Class|Expression self transformation (always *outer*)|Expression child nodes transformations (all children always visited)|Children Transformation type (inner/outer)|Comments

|EmptyExpression|No transformation|No transformation|Outer|
|MapEntryExpression|No transformation|* keyExpression
* valueExpression|Outer|
|ArgumentListExpression|No transformation|No transformation|Outer|

|DeclarationExpression|<<Declaration Expression transformation>>|* rightExpression
|Outer|

|BinaryExpression|<<Standard Expression transformation>>|* rightExpression
* leftExpression (only when operation is *not* "Assignment" ("="))|Outer|

|BitwiseNegationExpression|<<Standard Expression transformation>>|* expression
|Outer|

|NotExpression|<<Standard Expression transformation>>|* expression
|Outer|

|BooleanExpression|<<Standard Expression transformation>>|* expression
|Outer|

|CastExpression|<<Standard Expression transformation>>|* expression
|Outer|

|ConstructorCallExpression|<<Standard Expression transformation>>|* arguments
|Outer|

|MethodPointerExpression|<<Standard Expression transformation>>|* expression
* methodName
|Outer|

|AttributeExpression|<<Standard Expression transformation>>|* objectExpression
* property
|Outer|

|PropertyExpression|<<Standard Expression transformation>>|* objectExpression
* property
|Outer|

|RangeExpression|<<Standard Expression transformation>>|* from
* to
|Outer|

|SpreadExpression|<<Standard Expression transformation>>|* expression
|Outer|

|SpreadMapExpression|<<Standard Expression transformation>>|* expression
|Outer|

|StaticMethodCallExpression|<<Standard Expression transformation>>|* arguments
|Outer|

|ElvisOperatorExpression|<<Standard Expression transformation>>|* trueExpression
* falseExpression
|Outer|

|TernaryExpression|<<Standard Expression transformation>>|* booleanExpression
* trueExpression
* falseExpression
|Outer|

|UnaryMinusExpression|<<Standard Expression transformation>>|* expression
|Outer|

|UnaryPlusExpression|<<Standard Expression transformation>>|* expression
|Outer|

|ConstantExpression
|<<Standard Expression transformation>>
|No
|N/A
|


|ClassExpression
|<<Standard Expression transformation>>
|No
|N/A
|


|VariableExpression
|<<Standard Expression transformation>>
|No
|N/A
|

|FieldExpression
|<<Standard Expression transformation>>
|No
|N/A
|TODO: Needs to be tested and probably should replicate PropertyExpression


|GStringExpression
|<<Standard Expression transformation>>
|* Values
|Inner
|

|ClosureListExpression
|<<Standard Expression transformation>>
|* Expressions
|Inner
|TODO: Needs to be tested



|===

=== Groovy class model

Refer to GroovyDoc:

* https://infinite-technology.github.io/BLACKBOX/

=== Runtime engine API

Refer to GroovyDoc:

* https://infinite-technology.github.io/BLACKBOX/io/infinite/blackbox/BlackBoxEngine.html

=== XSD model

==== File Structure

BlackBox XSD type (class) model is based upon a simplified Groovy AST class model, which allows easy adaptation of the original naming conventions (classes and field names).

===== BlackBox.xsd

The central XSD file *BlackBox.xsd* is having the following URL/namespace:

* https://i-t.io/blackbox/groovy/2_x_x/BlackBox.xsd

This file is used for the following purposes:

* This is the main XSD file
* JAXB Class generation
* Defines rootAstNode element - root element of BlackBox XML log files

XSD files in BlackBox solution are organized in similar way to Java classes - separate file per XML Type.
BlackBox.xsd contains imports for all dependencies.

==== Versioning

XSD/BlackBox versioning is linked to Groovy versioning, as it is dependent on AST Class model.

Current Groovy Production versions is:

* 2.5.3

Therefore BlackBox XSD has version 2.x.x which will accomodate any 2.5+.3+ changes as backward compatible.

When Groovy 3.x.x will be released a separate XSD file will be build along with BlackBox version.

==== XSD/JAXB class model diagram

NOTE: Classes generated by JAXB in BlackBox project have "XML" class name prefix.

image::https://infinite-technology.github.io/BLACKBOX/asciidoc/images/XSDClassModel.png[XSDClassModel]

==== BlackBox XSD Types

===== ASTNode

ASTNode XML type corresponds to Groovy ASTNode class.

TIP: http://docs.groovy-lang.org/docs/latest/html/api/org/codehaus/groovy/ast/ASTNode.html

In BlackBox project XSD types it is a super-class for 3 classes (which is normally specified by *xsi:type* attribute of ASTNode element):

* <<MethodNode>>
* <<expression-2, Expression>>
* <<statement-2, Statement>>

.Elements

[cols="a,a,a"]
|===
|Name|Type|Description

|restoredScriptCode|string|ASTNode code restored by Groovy AstNodeToScriptVisitor.

|astNodeList|<<ASTNodeList>>|List of child ASTNodes transformed by BlackBox and processed by runtime environment during program execution.

|===

.Atributes

[cols="a,a,a"]
|===
|Name|Type|Description

|startDateTime|datetime|Datetime when ASTNode evaluation/execution started.
|sourceNodeName|string|Standalone ASTNode such as BlockStatement has no awareness to where it belongs. +
However BlackBox adds a useful visibility to help to understand that e.g. BloackStatement is originating from "IfStatement:elseBlock". +
Format of this field is "Class name:field name" of the source variable where this AST Node is referenced.
|lineNumber|integer|Start line number of the ASTNode - you can use it to navigate into your code
|columnNumber|integer|Start column number of the ASTNode - you can use it to navigate into your code
|lastLineNumber|integer|Ending line number of the ASTNode - you can use it to navigate into your code
|lastColumnNumber|integer|Ending column number of the ASTNode - you can use it to navigate into your code

|===


===== ASTNodeList

* ASTNodeList represents collection of ASTNode objects.

.Elements

[cols="a,a,a"]
|===
|Name|Type|Description

|astNode|ASTNode|Collection element (unbounded occurrence)

|===

.Atributes
N/A


===== MethodNode

* MethodNode XML type corresponds to Groovy MethodNode class.
* MethodNode XML type corresponds to an invocation of <<User code>> method annotated with <<BlackBox Annotation>>.
* Method invocation is logged with <<4 BlackBox levels,BlackBox level>> "METHOD" and above.
* Method arguments and result are logged
* If exception occurs it is also logged for such methods

TIP: http://docs.groovy-lang.org/docs/latest/html/api/org/codehaus/groovy/ast/MethodNode.html

This is a subclass of ASTNode XML type.

.Elements

[cols="a,a,a"]
|===
|Name|Type|Description

|argumentList|<<ArgumentList>>|List of method <<Argument, Arguments>>
|exception|<<Exception>>|Method <<Exception>> (if present)
|methodResult|<<Object>>|Method result <<Object>> (if non-void and non-null return value of method)

IMPORTANT: above is one of the most important features of BlackBox - ability to track/review method arguments, exceptions and results.

|===

.Atributes

[cols="a,a,a"]
|===
|Name|Type|Description

|methodName|string|Method name (http://docs.groovy-lang.org/docs/latest/html/api/org/codehaus/groovy/ast/MethodNode.html#getName--)
|className|string|Canonical class name of method declaring class (http://docs.groovy-lang.org/docs/latest/html/api/org/codehaus/groovy/ast/AnnotatedNode.html#getDeclaringClass--)

|===



===== Statement

* Statement XML type corresponds to Groovy Statement class.
* Statement XML type corresponds to an execution of a statement within a <<User code>> method annotated with <<BlackBox Annotation>>.
* Statements are logged with <<4 BlackBox levels,BlackBox level>> "STATEMENT" and above.

TIP: http://docs.groovy-lang.org/docs/latest/html/api/org/codehaus/groovy/ast/stmt/Statement.html

NOTE: All Groovy Statements are supported.

This is a subclass of ASTNode XML type.

.Elements
N/A

.Atributes

[cols="a,a,a"]
|===
|Name|Type|Description

|statementClassName|string|Simple class name of Groovy Statement subclass, such as IfStatement.

|===


===== Expression

* Expression XML type corresponds to Groovy Expression class.
* Expression XML type corresponds to an evaluation or execution of an expression within a <<User code>> method annotated with <<BlackBox Annotation>>.
* Expressions are logged with <<4 BlackBox levels,BlackBox level>> "EXPRESSION".
* Expression evaluation result is logged

TIP: http://docs.groovy-lang.org/docs/latest/html/api/org/codehaus/groovy/ast/expr/Expression.html

NOTE: All Groovy Expressions are supported.

This is a subclass of ASTNode XML type.

.Elements

[cols="a,a,a"]
|===
|Name|Type|Description

|expressionValue|<<Object>>|<<Object>> to which the expression has been evaluated.

IMPORTANT: above is one of the most important features of BlackBox - ability to track/review Object values in transition between expressions.

|===

.Atributes

[cols="a,a,a"]
|===
|Name|Type|Description

|expressionClassName|string|Simple class name of Groovy Expression subclass, such as MethodCallExpression.

|===


===== Argument

* Represents Method Argument object

NOTE: "toString()" method is used to serialize objects.

.Elements

[cols="a,a,a"]
|===
|Name|Type|Description

|argumentValue|string|"toString()" representation of method argument object.

|===

.Atributes

[cols="a,a,a"]
|===
|Name|Type|Description

|argumentClassName|string|Canonical class name of method argument object class
|argumentName|string|Argument variable (parameter) name as per method signature in <<User code>>

|===

===== ArgumentList

* ArgumentList represents collection of Argument objects.

.Elements

[cols="a,a,a"]
|===
|Name|Type|Description

|argument|Argument|Collection element (unbounded occurrence)

|===

.Atributes
N/A

===== Object

* Represents any Java object such as result of <<expression-2>> evaluation.

NOTE: "toString()" method is used to serialized objects.

.Elements

[cols="a,a,a"]
|===
|Name|Type|Description

|value|string|"toString()" representation of the object.

|===

.Atributes

[cols="a,a,a"]
|===
|Name|Type|Description

|className|string|Canonical class name of object class

|===

===== Exception

* Represents Java Throwable object, such as Exception occured during MethodNode execution.

NOTE: org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace method is used to serialize the Throwable.

.Elements

[cols="a,a,a"]
|===
|Name|Type|Description

|exceptionStackTrace|string|Throwable stacktrace serialized using org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace

|===

.Atributes

[cols="a,a,a"]
|===
|Name|Type|Description

|exceptionDateTime|datetime|Datetime when exception was caught.

|===

== Risks
=== Performance
==== ThreadLocal usage

BlackBox currently is using its own custom (very simple) implementation of ThreadLocal.

The reason being is that Java Application Servers interfere with normal java.lang.ThreadLocal and re-initialize its static fields.

However there is a performance downside - all logging calls are initiated using:

[source, groovy]
BlackBoxEngine.getInstance()

- which in its turn is using HashMap to get the actual instance of the logger.

This definitely is not the fastest approach and this should be considered.

==== Closure usage

All methods and expressions are enclosed into Groovy Closures and executed using "call()" method.

Therefore BlackBox performance is dependent on Closure execution performance in Groovy.

=== Security
==== Automatic logging of sensitive data

Sensitive data such as Cardholder data, passwords and personal data can be accidently automatically logged when such data is in variable scope of methods annotated with BlackBox annotation.

=== Test coverage and code disruption

BlackBox is traversing and transforming whole AST of <<User code>>.

Any violation of <<Code equivalency>> principle due to bug in BlackBox can cause catastrophic damage.

This is especially actual since the BlackBox annotation addition is subtle in terms of regression impact analysis.

== Usage
=== Preparation
==== Checkout

Checkout the default branch of the project:

* https://github.com/INFINITE-TECHNOLOGY/BLACKBOX

==== Building

<1> Run jaxb Gradle task
<2> Run build Gradle task
<3> Run uploadArchives Gradle task (Maven Local repository should be configured)

=== In the <<User code>>
==== Import using Gradle

Add BlackBox dependency from Local repository:

[source, gradle]
----
...
mavenLocal()
...
compile 'io.infinite:blackbox:2.0.0'
...
----

==== Using annotation

Add <<BlackBox Annotation>> to <<User code>> Methods and constructors as shown below:

[source,groovy]
----
@BlackBox
String foo() {
    return "bar"
}
----

=== During the runtime

To control <<Operating modes>> of BlackBox during runtime, use Java System property:

----
blackbox.mode=SEQUENTAL
----
or
----
blackbox.mode=EMERGENCY
----